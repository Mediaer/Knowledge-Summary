###### cp命令总结 ###### 
-u, --update
copy only when the SOURCE file is newer than the destination file or when the destination file is missing

###### export命令总结 ######
用于设置或者显示变量
在shell中执行程序时，shell会提供一组环境变量。export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅基于该次登陆操作
export -p ：打印shell赋予程序的环境变量

###### alias命令总结 ######
alias ll='ls -l'  //为ll起别名
unalias ll        //取消ll别名

保存别名配置：
在 /etc/profile 中添加
在 ~/.bash_profile 中添加

###### sed命令总结 ###### 

###### awk命令总结 ######
###### grep命令总结 ######
###### tee命令总结 ######
###### indent命令总结 ######

###### pushd、popd、dirs命令总结 ######
pushd：
1.每次pushd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容
2.目录栈的栈顶永远存放的是当前目录
3.pushd不带任何参数执行的效果就是 cd - ，栈顶两个目录互相切换
4.pushd +n切换到目录栈中的第n个目录，并将该目录以栈循环的方式推到栈顶

dirs:
  -v  每行显示一条记录，同时展示该记录在栈中的index
  -c  清空目录栈
  
###### 构建基本脚本 ######
1. 用户变量
   var1=10
   var2=12
在变量,等号,和值之间不能出现空格
2. 命令替换
两种方法将命令输出赋给变量
 #1 反引号字符(`)
    testing=`date`   //将date命令的输出赋值给testing
 #2 $()格式
    testing=$(date)  //将date命令的输出赋值给testing
    today=$(date +%y%m%d) //告诉date将日期显示为两位数的年月日组合,比如:180811

3. 输出重定向
  who > test //重定向who命令输出结果到test
  如果输出文件已经存在,重定向操作符会使用新的数据覆盖已有文件
  如果不想覆盖文件原有内容,可以追加到已有文件, (>>)来追加数据

4. 执行数学运算
 #1 expr 命令
   expr 5 \* 2  //注意转义符的使用
 
将数学运算结果赋值给一个变量有两种方法:
var1=10
var2=20
var3=$(expr $var2 / $var1)
echo The result is $var3
这种方法需要使用命令替换来获取expr的运算结果,另一种较为简便的方法为

在bash中,可以将一个数学运算结果赋值给某一个变量,使用美元符和方括号, $[operation] 将数学表达式围起来
var1=10
var2=20
var3=$[$var2 / $var1]

###### shell结构化命令 ######
1.基本结构1 
if command
then
    commands
fi

bash shell的if语句后面命令.如果退出状态码是0(表示执行成功),位于then后面的命令就会执行,否则不执行
另外一种形式:
if command; then
    commands
fi
****************************
if command
then
   commands
else
   commands
fi
****************************
if command
then
   commands
elif command2
then
   more commands
fi
****************************

if-then语句不能测试命令退出码之外的条件,可以使用test命令来扩充

****************************
if test condition    //条件成立,test命令退出返回状态码0,否则退出返回非0退出状态码
then
    commands
fi
****************************
test可以测试三类条件:
@ 数值比较  (eq,ge,gt,le,lt,ne)
@ 字符串比较 (=, !=, < , >, -n(字符长度是否非0), -z(字符长度是否为0))
@ 文件比较


2. 基本结构2

for命令:
//////////////////////
for var in list
do
	commands
done
//////////////////////
for (( i=1; i <= 10; i++))
do
    echo "The next number is $i"
done
//////////////////////

while 命令:
///////////////////////
while test command
do
   other commands
done
//////////////////////
while [$var1 -gt 0]
do
   echo $var1
   var1=$[ $var1 - 1 ]
done
///////////////////////


处理循环的输出:
在shell中,可以对循环的输出使用管道或者重定向

for file in /home/rich/*
  do
    if [ -d '$file' ]
    then
       echo "$file is a dit=rectory"
    elif
       echo "$file is a file"
    fi
done > output.txt


/////////////////////////////// Linux隐藏命令操作历史 /////////////////////////////////////
1. 在命令前插入空格，这条命令会被shell忽略，前提是环境变量 HISTCONTROL 设置为"ignorespace"或者"ignoreboth"才会起作用
如果不生效，环境变量需要设置一下，export HISTCONTROL = ignorespace

2. 一劳永逸的做法是：使用软链接，history记录都是存放在 ~/.bash_history文件中，那么我们就可以将写入 ~/.bash_history转移到其他地方

ln -s /dev/null ~/.bash_history   //这样都写入到 /dev/null

恢复history正常做法：

rm -rf ~/.bash_history

注意不是：

rm -rf ~/.bash_history/

如果结尾有"/"，那么源文件也会被删除，只删除软连接的话，不能加"/"

//////////////////////////////// 配置环境变量并使之生效 ///////////////////////////////////////////
主要两个命令：export、source

export LD_LIBRARY_PATH=/home/ubuntu/opencv-3.1.0/lib:$LD_LIBRARY_PATH
export PKG_CONFIG_PATH=/home/ubuntu/opencv-3.1.0/lib/pkgconfig:$PKG_CONFIG_PATH

source ~/.bashrc

//////////////////////////////// screen命令 ///////////////////////////////////////////
//打开会话
screen "name"
//浏览当前的screen会话
screen -ls
//关闭screen会话
screen -X -S name quit
//恢复上次的screen对话
screen -ls
There are screens on:
7880.session    (Detached)
7934.session2   (Detached)
7907.session1   (Detached)
3 Sockets in /var/run/screen/S-root.

screen -r
screen -r 7934
screen -r -S session2

//////////////////////////////// Macro useage ///////////////////////////////////////////
//A is true and B is false
#define CHECK1(A,B,...) if ((A)&&!(B)) { printf(__VA_ARGS__); }  // ... 用 __VA_ARGS__ 来代替
// #, ##
使用#把宏参数变为一个字符串,用##把两个宏参数贴合在一起
宏定义里有用'#'或'##'的地方宏参数是不会再展开
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Usage one xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
我们使用#把宏参数变为一个字符串,用##把两个宏参数贴合在一起. 
用法: 
#include<cstdio> 
#include<climits> 
using namespace std; 
#define STR(s)     #s 
#define CONS(a,b)  int(a##e##b) 

int main() 
{ 
    printf(STR(vck));           // 输出字符串"vck" 
    printf("%d ", CONS(2,3));  // 2e3 输出:2000 
    return 0; 
} 
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxUsage two xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
二、当宏参数是另一个宏的时候 
需要注意的是凡宏定义里有用'#'或'##'的地方宏参数是不会再展开.
1, 非'#'和'##'的情况 
    #define TOW      (2) 
    #define MUL(a,b) (a*b) 
printf("%d*%d=%d ", TOW, TOW, MUL(TOW,TOW)); 
这行的宏会被展开为： 
    printf("%d*%d=%d ", (2), (2), ((2)*(2))); 
MUL里的参数TOW会被展开为(2). 


2, 当有'#'或'##'的时候 
    #define A          (2) 
    #define STR(s)     #s 
    #define CONS(a,b)  int(a##e##b) 
    printf("int max: %s",  STR(INT_MAX));    // INT_MAX #include<climits>
这行会被展开为： 
    printf("int max: %s", "INT_MAX"); 
    printf("%s", CONS(A, A));               // compile error 
这一行则是： 
    printf("%s", int(AeA)); 
INT_MAX和A都不会再被展开, 然而解决这个问题的方法很简单. 加多一层中间转换宏. 
加这层宏的用意是把所有宏的参数在这层里全部展开, 那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数. 
    #define A           (2)
    #define _STR(s)     #s 
    #define STR(s)      _STR(s)          // 转换宏 
    #define _CONS(a,b)  int(a##e##b) 
    #define CONS(a,b)   _CONS(a,b)       // 转换宏 
    printf("int max: %s", STR(INT_MAX));          // INT_MAX,int型的最大值，为一个变量 #include<climits>
输出为: int max: 0x7fffffff 
STR(INT_MAX) -->  _STR(0x7fffffff) 然后再转换成字符串； 
printf("%d", CONS(A, A)); 
输出为：200CONS(A, A)  -->  _CONS((2), (2))  --> int((2)e(2))
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx









 
  

